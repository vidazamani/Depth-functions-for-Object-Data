library(ICtest)
library(abind)
library(CovTools)
library(ggplot2)
library(dplyr)
library(purrr)
library(parallel)
library(dplyr)


# generate data function 

# A helper function
#
rsphere <- function(n, p, lambda){
  x <- matrix(rnorm(n*p, lambda, 1), n, p)
  x_norm <- apply(x, 1, function(v) sqrt(sum(v^2)))
  return(sweep(x, 1, x_norm, "/"))
}



cont_sample <- function(n, p, eps, lambda_1){
  n1 <- floor((1 - eps)*n)
  n2 <- n - n1
  
  x1 <- rsphere(n1, p, lambda_1)
  x2 <- rsphere(n2, p, -1)
  
  rbind(x1, x2)
  
}


source("C:/Users/vizama/Documents/1st paper/Box_Parallel/Codes/All Metric depth functions.R")



simulation_with_sph <- function(n, p, eps, lambda_1){
  
  
  # generate data
  many_S <- cont_sample(n, p, eps, lambda_1)
  
  # Compute the distance matrix between the corr matrices
  
  
  # Distance matrix
  suppressWarnings(D <- acos(tcrossprod(many_S)))
  diag(D) <- rep(0, nrow(D))
  
  
  
  
  ############## Running Time of each depth ###################
  
  start_time = Sys.time()
  MHD(D)
  end_time = Sys.time()
  MHDt <- end_time - start_time
  
  start_time = Sys.time()
  MSD(D)
  end_time = Sys.time()
  MSDt <- end_time - start_time
  
  
  start_time = Sys.time()
  MLD(D)
  end_time = Sys.time()
  MLDt <- end_time - start_time
  
  
  start_time = Sys.time()
  MOD2(D)
  end_time = Sys.time()
  MOD2t <- end_time - start_time
  
  
  start_time = Sys.time()
  MOD3(D)
  end_time = Sys.time()
  MOD3t <- end_time - start_time
  
  ###########################################
  
  ##### Computing Error #####
  
  MHDD = order(MHD(D))[n] ; MSDD = order(MSD(D))[n] 
  MLDD = order(MLD(D))[n] ; MODD2 = order(MOD2(D))[n]
  MODD3 = order(MOD3(D))[n]
  
  
  tudeepest = many_S[MHDD,]
  spdeepest = many_S[MSDD,]
  lensdeepest = many_S[MLDD,]
  oja2deepest = many_S[MODD2,]
  oja3deepest = many_S[MODD3,]
  
  
  # Distance between two points
  
  tudiff1 = acos(sum(tudeepest*(1/sqrt(p)*rep(1,p))))
  
  
  spdiff1 = acos(sum(spdeepest*(1/sqrt(p)*rep(1,p))))
  
  
  lendiff1 = acos(sum(lensdeepest*(1/sqrt(p)*rep(1,p))))
  
  
  oja2diff1 = acos(sum(oja2deepest*(1/sqrt(p)*rep(1,p))))
  
  
  oja3diff1 = acos(sum(oja3deepest*(1/sqrt(p)*rep(1,p))))
  
  
  depths_error <- c(tudiff1, spdiff1, lendiff1, oja2diff1, oja3diff1)
  time_consumption <- c(MHDt,MSDt,MLDt,MOD2t,MOD3t)
  
  result <- data.frame(depths_error,time_consumption)
  return(result)
  
}


starttime <- Sys.time()

# Parameters

n <- c(10,20,30,40,50,60)

p = 10

eps = 0.05

lambda_1 = 5 ## it is similar to mu


par_grid <- expand.grid(sample_size = n,
                        matrix_dimension = p,
                        outlier_rate = eps, 
                        mean = lambda_1)


par_n <- nrow(par_grid)


iter = 500
temp <- list()
output <- matrix(0)
a <- list()
b <- data.frame()
b_all <- data.frame()



cl <- makeCluster(4)
clusterExport(cl, ls(), envir = environment())
clusterExport(cl, c("rorth","abind", "CovDist"), envir = environment())


clusterEvalQ(cl, set.seed(2222))
set.seed(1111)
seed_vec <- sample(1:100000, iter)




for (j in 1:iter) {
  
  set.seed(seed_vec[j])
  
  temp <- parSapply(cl, 1:par_n, function(i) simulation_with_sph(par_grid$matrix_dimension[i],
                                                                 par_grid$sample_size[i],
                                                                 par_grid$outlier_rate[i],
                                                                 par_grid$mean[i]))
  
  output <- matrix(unlist(temp), ncol = 5, byrow = TRUE)
  
  a = lapply(1:5, function(i) data.frame(par_grid, 
                                         errorD = output[seq(1,2*length(n),2),i],
                                         howlong = output[seq(2,2*length(n),2),i],
                                         method = i))
  
  b = list_rbind(a)
  b_all <- rbind(b_all,b)
  
}





b_all$method <- factor(b_all$method, 1:5, c("Metric Lens depth",
                                            "Metric Half-space depth",
                                            "Metric Spatial depth",
                                            "Metric Oja depth 2D",
                                            "Metric Oja depth 3D"))

bagg = b_all %>% 
  group_by(method,mean,outlier_rate,matrix_dimension,sample_size) %>% 
  summarise(avg_error = mean(errorD), avg_time = mean(howlong))



write.table(bagg,
            file = "C:\\Users\\vizama\\Documents\\1st paper\\Simulation results on sphere dataset\\data\\p10eps0.05.txt")

stopCluster(cl)



######### Parameters 

p <- 10

# number of random corr matrices
n <- c(10,20,30,40,50,60)

# n <- c(10,20)

# Proportion of outliers (To check the robustness of our methods)
eps <- 0.3

# How outlying the outliers are
lambda_1 = 5 ## it is similar to mu


par_grid <- expand.grid(sample_size = n,
                        matrix_dimension = p,
                        outlier_rate = eps, 
                        mean = lambda_1)


par_n <- nrow(par_grid)


iter = 500
temp <- list()
output <- matrix(0)
a <- list()
b <- data.frame()
b_all <- data.frame()



cl <- makeCluster(4)
clusterExport(cl, ls(), envir = environment())
clusterExport(cl, c("rorth","abind", "CovDist"), envir = environment())


clusterEvalQ(cl, set.seed(2222))
set.seed(1111)
seed_vec <- sample(1:100000, iter)




for (j in 1:iter) {
  
  set.seed(seed_vec[j])
  
  temp <- parSapply(cl, 1:par_n, function(i) simulation_with_sph(par_grid$matrix_dimension[i],
                                                                 par_grid$sample_size[i],
                                                                 par_grid$outlier_rate[i],
                                                                 par_grid$mean[i]))
  
  output <- matrix(unlist(temp), ncol = 5, byrow = TRUE)
  
  a = lapply(1:5, function(i) data.frame(par_grid, 
                                         errorD = output[seq(1,2*length(n),2),i],
                                         howlong = output[seq(2,2*length(n),2),i],
                                         method = i))
  
  b = list_rbind(a)
  b_all <- rbind(b_all,b)
  
}





b_all$method <- factor(b_all$method, 1:5, c("Metric Lens depth",
                                            "Metric Half-space depth",
                                            "Metric Spatial depth",
                                            "Metric Oja depth 2D",
                                            "Metric Oja depth 3D"))

bagg = b_all %>% 
  group_by(method,mean,outlier_rate,matrix_dimension,sample_size) %>% 
  summarise(avg_error = mean(errorD), avg_time = mean(howlong))



write.table(bagg,
            file = "C:\\Users\\vizama\\Documents\\1st paper\\Simulation results on sphere dataset\\data\\p10eps0.3.txt")

stopCluster(cl)


######### Parameters 

p <- 15

# number of random corr matrices
n <- c(10,20,30,40,50,60)

# n <- c(10,20)

# Proportion of outliers (To check the robustness of our methods)
eps <- 0.05

# How outlying the outliers are
lambda_1 = 5 ## it is similar to mu


par_grid <- expand.grid(sample_size = n,
                        matrix_dimension = p,
                        outlier_rate = eps, 
                        mean = lambda_1)


par_n <- nrow(par_grid)


iter = 500
temp <- list()
output <- matrix(0)
a <- list()
b <- data.frame()
b_all <- data.frame()



cl <- makeCluster(4)
clusterExport(cl, ls(), envir = environment())
clusterExport(cl, c("rorth","abind", "CovDist"), envir = environment())


clusterEvalQ(cl, set.seed(2222))
set.seed(1111)
seed_vec <- sample(1:100000, iter)




for (j in 1:iter) {
  
  set.seed(seed_vec[j])
  
  temp <- parSapply(cl, 1:par_n, function(i) simulation_with_sph(par_grid$matrix_dimension[i],
                                                                 par_grid$sample_size[i],
                                                                 par_grid$outlier_rate[i],
                                                                 par_grid$mean[i]))
  
  output <- matrix(unlist(temp), ncol = 5, byrow = TRUE)
  
  a = lapply(1:5, function(i) data.frame(par_grid, 
                                         errorD = output[seq(1,2*length(n),2),i],
                                         howlong = output[seq(2,2*length(n),2),i],
                                         method = i))
  
  b = list_rbind(a)
  b_all <- rbind(b_all,b)
  
}





b_all$method <- factor(b_all$method, 1:5, c("Metric Lens depth",
                                            "Metric Half-space depth",
                                            "Metric Spatial depth",
                                            "Metric Oja depth 2D",
                                            "Metric Oja depth 3D"))

bagg = b_all %>% 
  group_by(method,mean,outlier_rate,matrix_dimension,sample_size) %>% 
  summarise(avg_error = mean(errorD), avg_time = mean(howlong))



write.table(bagg,
            file = "C:\\Users\\vizama\\Documents\\1st paper\\Simulation results on sphere dataset\\data\\p15eps0.05.txt")

stopCluster(cl)



######### Parameters 

p <- 15

# number of random corr matrices
n <- c(10,20,30,40,50,60)

# n <- c(10,20)

# Proportion of outliers (To check the robustness of our methods)
eps <- 0.3

# How outlying the outliers are
lambda_1 = 5 ## it is similar to mu


par_grid <- expand.grid(sample_size = n,
                        matrix_dimension = p,
                        outlier_rate = eps, 
                        mean = lambda_1)


par_n <- nrow(par_grid)


iter = 500
temp <- list()
output <- matrix(0)
a <- list()
b <- data.frame()
b_all <- data.frame()



cl <- makeCluster(4)
clusterExport(cl, ls(), envir = environment())
clusterExport(cl, c("rorth","abind", "CovDist"), envir = environment())


clusterEvalQ(cl, set.seed(2222))
set.seed(1111)
seed_vec <- sample(1:100000, iter)




for (j in 1:iter) {
  
  set.seed(seed_vec[j])
  
  temp <- parSapply(cl, 1:par_n, function(i) simulation_with_sph(par_grid$matrix_dimension[i],
                                                                 par_grid$sample_size[i],
                                                                 par_grid$outlier_rate[i],
                                                                 par_grid$mean[i]))
  
  output <- matrix(unlist(temp), ncol = 5, byrow = TRUE)
  
  a = lapply(1:5, function(i) data.frame(par_grid, 
                                         errorD = output[seq(1,2*length(n),2),i],
                                         howlong = output[seq(2,2*length(n),2),i],
                                         method = i))
  
  b = list_rbind(a)
  b_all <- rbind(b_all,b)
  
}





b_all$method <- factor(b_all$method, 1:5, c("Metric Lens depth",
                                            "Metric Half-space depth",
                                            "Metric Spatial depth",
                                            "Metric Oja depth 2D",
                                            "Metric Oja depth 3D"))

bagg = b_all %>% 
  group_by(method,mean,outlier_rate,matrix_dimension,sample_size) %>% 
  summarise(avg_error = mean(errorD), avg_time = mean(howlong))



write.table(bagg,
            file = "C:\\Users\\vizama\\Documents\\1st paper\\Simulation results on sphere dataset\\data\\p15eps0.3.txt")

stopCluster(cl)


######### Parameters 

p <- 20

# number of random corr matrices
n <- c(10,20,30,40,50,60)

# n <- c(10,20)

# Proportion of outliers (To check the robustness of our methods)
eps <- 0.05

# How outlying the outliers are
lambda_1 = 5 ## it is similar to mu


par_grid <- expand.grid(sample_size = n,
                        matrix_dimension = p,
                        outlier_rate = eps, 
                        mean = lambda_1)


par_n <- nrow(par_grid)


iter = 500
temp <- list()
output <- matrix(0)
a <- list()
b <- data.frame()
b_all <- data.frame()



cl <- makeCluster(4)
clusterExport(cl, ls(), envir = environment())
clusterExport(cl, c("rorth","abind", "CovDist"), envir = environment())


clusterEvalQ(cl, set.seed(2222))
set.seed(1111)
seed_vec <- sample(1:100000, iter)




for (j in 1:iter) {
  
  set.seed(seed_vec[j])
  
  temp <- parSapply(cl, 1:par_n, function(i) simulation_with_sph(par_grid$matrix_dimension[i],
                                                                 par_grid$sample_size[i],
                                                                 par_grid$outlier_rate[i],
                                                                 par_grid$mean[i]))
  
  output <- matrix(unlist(temp), ncol = 5, byrow = TRUE)
  
  a = lapply(1:5, function(i) data.frame(par_grid, 
                                         errorD = output[seq(1,2*length(n),2),i],
                                         howlong = output[seq(2,2*length(n),2),i],
                                         method = i))
  
  b = list_rbind(a)
  b_all <- rbind(b_all,b)
  
}





b_all$method <- factor(b_all$method, 1:5, c("Metric Lens depth",
                                            "Metric Half-space depth",
                                            "Metric Spatial depth",
                                            "Metric Oja depth 2D",
                                            "Metric Oja depth 3D"))

bagg = b_all %>% 
  group_by(method,mean,outlier_rate,matrix_dimension,sample_size) %>% 
  summarise(avg_error = mean(errorD), avg_time = mean(howlong))



write.table(bagg,
            file = "C:\\Users\\vizama\\Documents\\1st paper\\Simulation results on sphere dataset\\data\\p20eps0.05.txt")

stopCluster(cl)



######### Parameters 

p <- 20

# number of random corr matrices
n <- c(10,20,30,40,50,60)

# n <- c(10,20)

# Proportion of outliers (To check the robustness of our methods)
eps <- 0.3

# How outlying the outliers are
lambda_1 = 5 ## it is similar to mu


par_grid <- expand.grid(sample_size = n,
                        matrix_dimension = p,
                        outlier_rate = eps, 
                        mean = lambda_1)


par_n <- nrow(par_grid)


iter = 500
temp <- list()
output <- matrix(0)
a <- list()
b <- data.frame()
b_all <- data.frame()



cl <- makeCluster(4)
clusterExport(cl, ls(), envir = environment())
clusterExport(cl, c("rorth","abind", "CovDist"), envir = environment())


clusterEvalQ(cl, set.seed(2222))
set.seed(1111)
seed_vec <- sample(1:100000, iter)




for (j in 1:iter) {
  
  set.seed(seed_vec[j])
  
  temp <- parSapply(cl, 1:par_n, function(i) simulation_with_sph(par_grid$matrix_dimension[i],
                                                                 par_grid$sample_size[i],
                                                                 par_grid$outlier_rate[i],
                                                                 par_grid$mean[i]))
  
  output <- matrix(unlist(temp), ncol = 5, byrow = TRUE)
  
  a = lapply(1:5, function(i) data.frame(par_grid, 
                                         errorD = output[seq(1,2*length(n),2),i],
                                         howlong = output[seq(2,2*length(n),2),i],
                                         method = i))
  
  b = list_rbind(a)
  b_all <- rbind(b_all,b)
  
}





b_all$method <- factor(b_all$method, 1:5, c("Metric Lens depth",
                                            "Metric Half-space depth",
                                            "Metric Spatial depth",
                                            "Metric Oja depth 2D",
                                            "Metric Oja depth 3D"))

bagg = b_all %>% 
  group_by(method,mean,outlier_rate,matrix_dimension,sample_size) %>% 
  summarise(avg_error = mean(errorD), avg_time = mean(howlong))



write.table(bagg,
            file = "C:\\Users\\vizama\\Documents\\1st paper\\Simulation results on sphere dataset\\data\\p20eps0.3.txt")

stopCluster(cl)




endtime <- Sys.time()
duration <- endtime - starttime




############# Visualization ###############

p10eps0.3 <- read.csv("C:/Users/vizama/Documents/1st paper/Simulation results on sphere dataset/data/p10eps0.3.txt", sep="")
p10eps0.05 <- read.csv("C:/Users/vizama/Documents/1st paper/Simulation results on sphere dataset/data/p10eps0.05.txt", sep="")
p15eps0.3 <- read.csv("C:/Users/vizama/Documents/1st paper/Simulation results on sphere dataset/data/p15eps0.3.txt", sep="")
p15eps0.05 <- read.csv("C:/Users/vizama/Documents/1st paper/Simulation results on sphere dataset/data/p15eps0.05.txt", sep="")
p20eps0.3 <- read.csv("C:/Users/vizama/Documents/1st paper/Simulation results on sphere dataset/data/p20eps0.3.txt", sep="")
p20eps0.05 <- read.csv("C:/Users/vizama/Documents/1st paper/Simulation results on sphere dataset/data/p20eps0.05.txt", sep="")


Data <- bind_rows(p10eps0.3,
                  p10eps0.05,
                  p15eps0.3,
                  p15eps0.05,
                  p20eps0.3,
                  p20eps0.05)

# New facet label names for matrix dimension variable
mtd.labs <- c("P = 10", "P = 15", "P = 20")
names(mtd.labs) <- c(10, 15, 20)

# New facet label names for outlier rate variable
otl.labs <- c("outlier rate = 5%", "outlier rate = 30%")
names(otl.labs) <- c("0.05", "0.3")




plot = ggplot(Data,aes(x = sample_size, y = avg_error, col = method))+ 
  facet_grid(matrix_dimension~outlier_rate,
             labeller = labeller(matrix_dimension = mtd.labs,
                                 outlier_rate = otl.labs))+
  geom_line(linewidth = 0.7)+
  scale_x_continuous(name="sample size")+
  scale_y_continuous(name = 'bias')+
  theme_bw()+ 
  labs(title = "Performance of each Metric Depth Function", 
       subtitle = "when points on surface (P) and outlier rate increase")+ 
  theme(plot.title = element_text(size = 12), 
        plot.subtitle = element_text(size = 9))+
  scale_y_log10()




plot2 = ggplot(Data,aes(x = sample_size, y = avg_time, col = method))+ 
  facet_grid(matrix_dimension~outlier_rate,
             labeller = labeller(matrix_dimension = mtd.labs,
                                 outlier_rate = otl.labs))+
  geom_line(linewidth = 0.7)+
  scale_y_log10(name = 'log of running time')+
  scale_x_continuous(name="sample size")+
  labs(title = 'Running time of each Metric Depth Function',
       subtitle = "when points on surface (P) and outlier rate increase")+
  theme(plot.title = element_text(size = 5))+
  theme_bw()


plot3 = ggplot(Data,aes(x = sample_size, y = avg_error, col = method,linetype = factor(outlier_rate)))+ 
  facet_grid(matrix_dimension~.)+
  geom_line(linewidth = 0.7)+
  scale_x_continuous(name="sample size")+
  theme_bw()+ 
  labs(title = "Performance of each Metric Depth Function", 
       subtitle = "when matrix dimnesion is 3 and 5% of Distribution is contaminated",
       y = 'Bias in log scale')+ 
  theme(plot.title = element_text(size = 12), 
        plot.subtitle = element_text(size = 9))+
  scale_y_log10()


###### Uni Plot
plotuni = ggplot(p3eps0.3,aes(x = sample_size, y = avg_error, col = method))+ 
  geom_line(linewidth = 0.7)+
  scale_x_continuous(name="sample size")+
  scale_y_continuous(name = 'Average Error')+
  theme_bw()+ 
  labs(title = "Performance of each Metric Depth Function", 
       subtitle = "when matrix dimnesion is 3 and 5% of Distribution is contaminated")+ 
  theme(plot.title = element_text(size = 12), 
        plot.subtitle = element_text(size = 9))






















